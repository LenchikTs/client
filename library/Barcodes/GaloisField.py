#!/usr/bin/env python
# -*- coding: utf-8 -*-

#############################################################################
##
## Copyright (C) 2021 SAMSON Group. All rights reserved.
##
#############################################################################
##
## Это программа является свободным программным обеспечением.
## Вы можете использовать, распространять и/или модифицировать её согласно
## условиям GNU GPL версии 3 или любой более поздней версии.
##
#############################################################################
##
##   Арифметика в полях Галуа
##
##   Полем называется множество, на котором определены
##   произвольные операции, называемые сложением, умножением,
##   вычитанием и делением, (кроме деления на 0)
##   в соответствии с аксиомами поля:
##
##   - Коммутативность сложения: a+b = b+a
##   - Ассоциативность сложения: (a+b)+c = a+(b+c)
##   - Существование нулевого элемента u: a+u = a
##   - Существование противоположного элемента: a + (-a) = u
##   - Коммутативность умножения: a*b = b*a
##   - Ассоциативность умножения: (a*b)*c = a*(b*c)
##   - Существование единичного элемента e: a*e = a
##   - Существование обратного элемента для ненулевых элементов: a* (a**-1) = e
##   - Дистрибутивность умножения относительно сложения (a+b)*c = a*c + b*c
##
##   (Для обычного сложения e=0, а u=1.)
##
##   Заметте, что умножение и сложение, которые определены 
##   для полей, могут не иметь ничего общего с обычным сложением 
##   или умножением кроме выполнения вышеупомянутых законов. 
##   Так, если в традиционной арифметике a + a = 2*a,
##   То в нашем случае a + a = 0. :/
##
##   Полями Галуа называются поля, в которых присутствует 
##   конечное число элементов. Поле Галуа с количеством 
##   элементов N обозначается GF(N).
##
##   Для наших задач нужны поля Галуа определённого типа. 
##   В нашем случае N равно 2**k (QR-коды: 2**8), 
##   т.о. примитивный элемент (часто обозначается α) равен 2.
##
##   Определим сложение, как операцию «исключающее ИЛИ» (XOR). 
##   Очевидно, что в таком случае нулевой элемент имеет значение 
##   0 и операция сложения совпадает с операцией вычитания:
##
##   a + 0 -> a
##   a - 0 -> a
##   a + a -> 0 (да, каждый элемент противоположен себе)
##   a - a -> 0
##
##   Операция умножения в двоичном виде будет выглядеть так 
##   почти как обычная операция умножения «в столбик», 
##   но сложение строк происходит «по нашему», XOR-ом
##   При этом если результат умножения превышает достигает 
##   (или превышает) N,
##   то мы берём остаток от деления на «примитивный» «неприводимый многочлен».
##   Остаток тоже наш, XOR-овый.
##   Для N=16 я нашёл два таких «многочлена»
##    - x**4+x+1    ( == 0b10011 == 19 )
##    - x**4+x**3+1 ( == 0b11001 == 25 )
##
##   Для N = 16 и modulo = 0b10011 :
##       2*5:
##           0010
##         * 0101
##           ----
##           0010
##       + 0010
##         ------
##         001010 -> 10
##
##       7*6:
##           0111
##         * 0110
##           ----
##           0000
##       +  0111
##       + 0111
##         ------
##         010010 <- теперь считаем остаток
##       +  10011
##         ------
##           0001 -> 1
##
##       15*11:
##           1111
##         * 1011
##           ----
##           1111
##      +   1111
##      + 1111
##        -------
##        1101001  <- теперь считаем остаток
##       +10011
##        -------
##         100101
##        +10011
##        -------
##           0011 -> 3
##
##   Деление похоже на деление уголком, но вычитания наши, XOR-овые
##
##   Традиционно никто не реализует умножение и деление «по честному»
##   Обычно составляют таблицу степеней примитивного элемента 
##
##   exp[k: k in 0..N-1] = α**k
##
##   (ни одна из экспонент не равна 0, N и modulo выбраны так, что
##   при k in 0..N-2 все значения различны, α**0 == α**(N-1) == 1)
##
##   и обратную ей таблицу логарифмов -
##
##   log[α**k] = k
##   (log[0] по понятным причинам не определён)
##
##   и вычисляют произведение ненулевых x*y
##   как exp[ (log[x] + log[y]) % (N-1) ]
##   (эй, здесь сложение и остаток вполне обычные!)
##
##   2*5 = exp[ (log[2] + log[5]) % 15 ] = exp[ (1+8)%15 ]  = exp[9] = 10
##   7*6 = exp[ (log[7] + log[6]) % 15 ] = exp[ (10+5)%15 ] = exp[0] = 1
##   15*11 = exp[ (log[15] + log[11]) % 15 ] = exp[ (12+7)%15 ] = exp[4] = 3
##   совпало :)
##
##   Кстати, (x+y)**2 =
##       = (x+y)*(x+y)
##       = x*(x+y) + y*(x+y)
##       = x*x + x*y + y*x + y*y
##       = x**2 + (x*y + x*y) + y**2
##       = x**2 + y**2
##
##   или вот так - x**2 + y**2 =
##       = x**2 - y**2
##       = (x+y)*(x-y)
##       = (x+y)*(x+y)
##       = (x+y)**2
##
##   Отмазка: я не знаю о применении полей Галуа с другими
##   операциями сложения и умножения.
##   Если такие найдутся, то класс буден нужно переименовать.
##
#############################################################################

class GF:
    def __init__(self, size, modulo):
        self.primitiveElement = 2
        # size должно быть степенью примитивного элемента
        self.size = size
        # modulo должно быть size < modulo < size*primitiveElement
        self.exp, self.log = self._generateExpAndLog(size, modulo, self.primitiveElement)


    def add(self, x, y):
        return x ^ y


    def mult(self, x, y):
        return self.exp[ (self.log[x] + self.log[y]) % (self.size-1) ]


    @staticmethod
    def _generateExpAndLog(size, modulo, primitiveElement):
        assert size < modulo < size*primitiveElement
        t = 1
        exp = [0] * size
        log = [None] * size # None: для log[0]
        for i in xrange(size-1):
            exp[i] = t
            log[t] = i
            t *= primitiveElement
            if t >= size:
                t ^= modulo
        exp[size-1] = t
        assert exp[-1] == exp[0] == 1
        assert len(set(exp)) == size-1
        return exp, log


if __name__ == '__main__':
#    f = GF(2**1, 0b11) # 3
#    f = GF(2**2, 0b111) # 7
#    f = GF(2**3, 0b1011) # 11
#    f = GF(2**3, 0x1101) # 13
    f = GF(2**4, 0b10011) # 19
#    f = GF(2**4, 0b11001) # 25

    print '  + |',
    for x in xrange(f.size):
        print '%3d' % x,
    print
    print '-'*4+'+'+'-'*(4*f.size)
    for y in xrange(f.size):
        print '%3d |' % y,
        for x in xrange(f.size):
            print '%3d' %  f.add(x,y),
        print

    print
    print '  * |',
    for x in xrange(f.size):
        print '%3d' % x,
    print
    print '-'*4+'+'+'-'*(4*f.size)
    for y in xrange(f.size):
        print '%3d |' % y,
        for x in xrange(f.size):
            print '%3d' % (f.mult(x,y) if x and y else 0),
        print

    print
    print '  k | log[k] | exp[k]'
    print '----+--------+-------'
    for k in xrange(f.size):
        print '%3d | %6r | %6r' % ( k, f.log[k], f.exp[k] )

#    N = 2**4
#    for p in xrange(N, 2*N):
#        try:
#            f = GF(N, p)
#            print 'ok:', N, p
#        except:
#            # print 'failed:', N, p
#            pass
